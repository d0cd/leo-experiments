program large_structs.aleo {
    struct Foo {
        m: [Message; 2],
    }
    struct Message {
        source_chain : [u128; 32],
        message_id : [u128; 32],
        source_address : [u128; 32],
        contract_address : [u128; 32],
        payload_hash : [u128; 32],
        source_chain1 : [u128; 32],
    }

    transition main() -> public Foo {
        let m: Message =  Message {
            source_chain: [5u128, 5u128, 5u128, 5u128, 5u128, 5u128, 5u128, 5u128, 5u128, 5u128, 5u128, 5u128, 5u128, 5u128, 5u128, 5u128, 5u128, 5u128, 5u128, 5u128, 5u128, 5u128, 5u128, 5u128, 5u128, 5u128, 5u128, 5u128, 5u128, 5u128, 5u128, 5u128],
            message_id: [6u128, 6u128, 6u128, 6u128, 6u128, 6u128, 6u128, 6u128, 6u128, 6u128, 6u128, 6u128, 6u128, 6u128, 6u128, 6u128, 6u128, 6u128, 6u128, 6u128, 6u128, 6u128, 6u128, 6u128, 6u128, 6u128, 6u128, 6u128, 6u128, 6u128, 6u128, 6u128],
            source_address: [7u128, 7u128, 7u128, 7u128, 7u128, 7u128, 7u128, 7u128, 7u128, 7u128, 7u128, 7u128, 7u128, 7u128, 7u128, 7u128, 7u128, 7u128, 7u128, 7u128, 7u128, 7u128, 7u128, 7u128, 7u128, 7u128, 7u128, 7u128, 7u128, 7u128, 7u128, 7u128],
            contract_address: [9u128, 9u128, 9u128, 9u128, 9u128, 9u128, 9u128, 9u128, 9u128, 9u128, 9u128, 9u128, 9u128, 9u128, 9u128, 9u128, 9u128, 9u128, 9u128, 9u128, 9u128, 9u128, 9u128, 9u128, 9u128, 9u128, 9u128, 9u128, 9u128, 9u128, 9u128, 9u128],
            payload_hash: [3u128, 3u128, 3u128, 3u128, 3u128, 3u128, 3u128, 3u128, 3u128, 3u128, 3u128, 3u128, 3u128, 3u128, 3u128, 3u128, 3u128, 3u128, 3u128, 3u128, 3u128, 3u128, 3u128, 3u128, 3u128, 3u128, 3u128, 3u128, 3u128, 3u128, 3u128, 3u128],
            source_chain1: [5u128, 5u128, 5u128, 5u128, 5u128, 5u128, 5u128, 5u128, 5u128, 5u128, 5u128, 5u128, 5u128, 5u128, 5u128, 5u128, 5u128, 5u128, 5u128, 5u128, 5u128, 5u128, 5u128, 5u128, 5u128, 5u128, 5u128, 5u128, 5u128, 5u128, 5u128, 5u128],
        };

        let f: Foo = Foo {
            m: [m, m],
        };
        return f;
    }
}
